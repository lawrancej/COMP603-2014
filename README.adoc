= COMP603 (Compiler Design)

== June 3

=== Lab 4
Optimize your compiler and interpreter developed in Lab 3.

. Modify +CommandNode+ so that it includes a counter (presumably an +int+ or the like).
. Modify the parser a bit so that it only emits a command node after it has encountered a full run of the same command. (e.g., +-----+ becomes +CommandNode(\'-', 5)+)
. Modify the interpreter and compiler accordingly.

In short: do an optimization that performs http://en.wikipedia.org/wiki/Run-length_encoding[run-length encoding] on Brainfuck code.

== June 2
Work on Labs 2-4.

== May 30

=== Symbol tables
A map among identifiers, scopes and other information (e.g., its type, where it's defined).

* In an interpreter, these can be used for data storage.
* In a compiler, these are used to generate code.

=== Type checking
Traverse an AST and verifying that it is put together correctly, and generate errors if not.

== May 28

=== Parsing techniques

Traditional approaches to parsing:

* http://en.wikipedia.org/wiki/Recursive_descent_parsing[Hand-written parsers] (tedious, error-prone)
* http://en.wikipedia.org/wiki/Parser_generator[Parser generator] (tedious, steep learning curve)

=== Parser combinators

Explain http://en.wikipedia.org/wiki/Parser_combinators[parser combinators] through code.

== May 27

=== Lab 3
This is a two-parter, building upon Lab 2.

. Compile Brainfuck to a language of your choice. Copypasta the Printer visitor class into, say, CCompiler or JavaCompiler. It should just print out equivalent C or Java or whatever source code.
. Interpret the AST by writing a Interpreter visitor that just executes commands based on the tree structure.

== May 23

=== Optimizations

* http://en.wikipedia.org/wiki/Optimizing_compiler[Compilers are really good at optimizations, because there's so many to choose from.]
* http://blog.codinghorror.com/the-infinite-space-between-words/[CPU is way faster than anything else, and how!]

=== Project ideas

For our project, we'll begin after we're done with our common labs (there aren't many left).
You're welcome to work with as few or as many people as you wish either in this section or others.
Start thinking about which of these you'd like to do, or suggest new ideas.

You're welcome to pursue these traditional project ideas:

* Implement some moderately simple language, like say, http://en.wikipedia.org/wiki/Cool_(programming_language)[Cool] or http://www.buildyourownlisp.com/[LISP].
* Something compiler-related that dovetails nicely with Senior project.

These ideas are also welcome:

* A parser combinator library to target multiple parsing strategies (derivative, shift-reduce, or recursive descent parsing).

These projects build upon tools like http://clang.llvm.org/docs/Tooling.html[clang] (for C/C++), http://www.vogella.com/tutorials/EclipseJDT/article.html[JDT] (for Java), https://docs.python.org/2/library/ast.html[Python's ast module] to do work:

* Automated refactoring tool for existing languages to serve education and large projects
* Search engine for identifiers and literals in code that makes good recommendations, (e.g., http://en.wikipedia.org/wiki/Pagerank[PageRank])
* Something like http://en.wikipedia.org/wiki/QuickCheck[Quickcheck], but can http://en.wikipedia.org/wiki/Characterization_test[generate characterization tests automatically] and efficiently.

== May 21

=== LR(k) grammars

LR(k) means *Left* to right, *Rightmost* derivation, with *k* tokens of lookahead.

LR(k) grammars are a subset of the context-free grammars, and a proper superset of the LL(k) grammars (the LL(k) grammars are a proper subset of the LR(k) grammars).
For a grammar to be LR(k):

* It must be unambiguous

LR(k) grammars can be parsed using 'shift-reduce'.

=== Shift-reduce parsing

Shift-reduce parsing is also known as bottom up parsing, because the parser works from the terminals up to the starting nonterminal.
A https://www.youtube.com/watch?v=uncfFsbUF68[shift-reduce parser] shifts terminals onto a stack, and reduces the stack to a nonterminal when the stack matches the right hand side of a production (rule).
Programmers rarely write shift-reduce parsers by hand, and use http://en.wikipedia.org/wiki/Parser_generator[parser generators] instead.

== May 20

=== Lab 2

Go ahead and pull from me:

----
cd COMP603-2014
git pull upstream master
----

Do you have Visual Studio or http://sourceforge.net/projects/mingw/files/latest/download?source=files[GCC] installed?

Write a recursive descent parser for http://en.wikipedia.org/wiki/Brainfuck[Brainfuck].

See +src/brainfuck.cpp+ for a starting point.
It makes use of the http://en.wikipedia.org/wiki/Visitor_pattern[Visitor design pattern].
If your C\++ is rusty, check out the http://www.cplusplus.com/reference/[C++ Reference].
To see an example of how to do recursive descent parsing, check out +src/RecursiveDescent.java+.

=== Hints
You can't avoid some form of recursion or use of a Node stack. Your options:

. Use mutually recursive functions that stuff child nodes into programs or loops
. Maintain an explicit stack of nodes inside the existing parse function
. Use an implicit stack by modifying +Node+ to include a pointer to a +parent+ Node

== May 19

=== Warm up

Answer in a file called +warmup.txt+

. What does it mean for two sets to be disjoint?
. What is the union of two sets?

=== First and follow sets

First set:: the set of terminals that can appear first in any derivation of a nonterminal.
Follow set:: the set of terminals that can appear first *after* derivation of a nonterminal.

See the scribbles (from page 148 of the textbook).

=== LL(k) grammars

LL(k) means parse from *Left* to right, *Leftmost* derivation, with at most *k* tokens of lookahead.

LL(k) grammars are a subset of the context-free grammars. For a grammar to be LL(k):

* The first and follow sets for each nonterminal must be disjoint
* It must be unambiguous
* No left-recursion is allowed
* No common prefixes on the right hand side are allowed

LL(k) grammars can be parsed using 'recursive descent'.

=== Recursive descent parsing

Recursive descent parsing is also known as top-down parsing, because the parse starts from the starting nonterminal.
Each nonterminal is a function, and the first and follow sets determine which production (rule) to choose.
See +src/RecursiveDescent.java+ for an example recursive descent parser.

== May 16

=== Derivatives

http://matt.might.net/articles/parsing-with-derivatives/[A discussion of derivatives and parsing with them].

=== Grammars

Grammars consist of:

. a finite set of derivation rules (productions)
. a finite set of nonterminals (variables)
. a finite set of terminals (literals)
. a starting nonterminal

Chomsky recognized that the restrictions placed on the form of derivation rules implies what category of language the grammar can recognize or generate.

NOTE: We will focus primarily on two subsets of context-free grammars, LL and LR grammars, since they have efficient parsing algorithms.

[cols="3", options="header"]
|===

|Chomsky hierarchy
|Description
|Equivalent automaton

|*Unrestricted*
|Arbitrary sequences of terminals and non-terminals can derive arbitrary sequences of terminals and nonterminals.
|Turing machine (finite state machine with an infinite tape having a read/write head)

|*Context-sensitive*
|A nonterminal flanked on either side by terminals and nonterminals (the context) derives a nonempty string of terminals or nonterminals surrounded by the same context.
|Turing machine with finite tape (finite state machine with a finite tape having a read/write head)

|*Context-free*
|Nonterminals derive sequences of terminals and nonterminals.
|Pushdown automaton (finite state machine with a stack)

|*Regular*
|A nonterminal can derive a terminal followed by a nonterminal or nothing at all.
|Finite state machine

|===

*Challenge*: Derive the parse tree for +int a = 5;+ using the C grammar. 'Hint:' it's a declaration.

== May 14

=== Warm up

Consider the following (fire up your command line and try these out):

----
echo 'Joey Lawrance' | sed -e 's/\(\w\w*\).*/Hello, \1!/'
echo 'lawrancej@wit.edu' | sed 's/\(.*\)@\(.*\)\.\(.*\)/\1 at \2 dot \3/'
echo 'deadbeef' | sed -e 's/^\([0-9a-f][0-9a-f]*\)$/Hex: \1/'
echo 'deadhorse' | sed -e 's/^\([0-9a-f][0-9a-f]*\)$/Hex: \1/'
----

With somebody sitting nearby, read the commands carefully and discuss these questions. 'Hint': +sed -e s/'REGEX'/'REPLACEMENT'/+

. How do you think it works?
. What do you think +\w+ means?
. What do +\1+, +\2+ and +\3+ mean?
. What does +[0-9a-f]+ mean?
. *Challenge*: Can you write a sed command to match only identifiers in, say, C/C++ or Java? Don't worry about reserved words. 'Hint': massage the last regex into something appropriate.

=== Regular Expressions and Finite State Machines

Regular expressions and finite state machines (finite automata) are interchangeable; we can always convert between them. Even non-deterministic and deterministic finite automata are interchangeable.

*Challenge*: Can you write finite state machines that correspond to the regular expressions above?

== May 13

Compilers translate source language(s) to target language(s), and typically consist of the following 'phases':

[cols="4", options="header"]
|===
|Phase
|Description
|Input
|Output

|*Scanning / Tokenization*
|Break source code up into small chunks (tokens) such as identifiers, reserved words, literals, operators, etc.
|Source code
|Token stream

|*Parsing*
|Check the syntax of the source code
|Token stream
|Parse tree

|*Translation*
|Translate low level syntax into high-level abstract syntax tree
|Parse tree
|Abstract syntax tree, symbol table

|*Optimization*
|Improve performance or structure
|Abstract syntax tree, symbol table
|Abstract synatx tree, symbol table

|*Code generation*
|Traverse the AST to generate code.
|Abstract syntax tree, symbol table
|Target code

|===

=== Lab 1

Do this individually, or in pairs.

NOTE: If working in a pair, go to your github repository settings (on the right side) and add the other person as a collaborator. Then, in your local git repository, add the collaborator's repository as a remote, using +git remote add 'COLLABORATOR' 'SSH_URL'+. Then +git fetch --all+. *DO NOT* push to your collaborator's repository, otherwise they'll be forced to merge in your changes before they can push. Always push to +origin+ (your github repository).

. Choose a single compiler implementation to review (suggestions welcome!)

  * https://github.com/chaoslawful/tcc[Tiny C compiler]
  * https://github.com/mirrors/gcc[GCC (Compiler for C/C++)]
  * https://github.com/llvm-mirror/llvm[LLVM (Compiler for C/C++)]
  * https://github.com/openjdk-mirror/jdk7u-jdk[OpenJDK (Compiler and runtime for Java)]
  * https://github.com/python/cpython[CPython]
  * https://bitbucket.org/pypy/pypy[PyPy]
  * https://github.com/LuaDist/lua[Lua]
  * https://github.com/ghc/ghc[GHC source (Haskell)]
  * https://github.com/ghcjs/ghcjs[GHCJS (Haskell to Javascript compiler)]
  * https://github.com/mozilla/rhino[Java implementation of Javascript]
  * https://github.com/mono/mono[C# compiler and runtime]

. Identify which files/functions are responsible for each phase in the compiler source.
. What was the most ridiculous thing you found? (funny comments? awful code?)
. Take notes along the way (if you find something that's unrelated to a compiler phase, try to infer what it's doing).
. Write up your findings in a short document and post to your repository (no more than two pages, please). For example:
+
----
git add findings.txt
git commit -m "Lab 1 findings."
git push origin master
----

=== Further reading

* http://cm.bell-labs.com/who/ken/trust.html[Reflections on Trusting Trust]
* https://www.schneier.com/blog/archives/2006/01/countering_trus.html[Countering "Trusting Trust"]

== May 12

=== Warm up

Cheat at crosswords (and learn about merge conflicts), the easy way!

. http://puzzles.about.com/library/features/dailyxwd/qprmon.htm[Open this crossword in a new tab]
. Pull from upstream
+
----
cd ~/COMP603-2014         # Go to your repo first
git pull upstream master  # Pull (fetch and merge) the latest and greatest from me
git mergetool             # Use KDiff3 to merge my stuff in (if you have a conflict)
----
. Find words that match something interesting, for example:
+
----
grep foo... american-english.txt
----

=== A case for Theory of Computation

WARNING: Theory of Computation ahead

. The first compiler (for Fortran) took 18 man-years of effort to produce back in the 1950s.
. CS theory has enabled CS undergraduates understand how to construct compilers within a semester.

=== A hierarchy of languages

Even though languages are sets of strings, it'd be difficult to define useful languages by enumerating all the strings in the set.
Therefore, CS theorists and mathematicians have developed handy short-cuts (formal grammars, state machines, etc.) to define languages.
Noam Chomsky categorized languages into a http://en.wikipedia.org/wiki/Chomsky_hierarchy[hierarchy that bears his name].

You've had experience with the most primitive languages (regular languages) and the most complex (recursively enumerable).

=== Regular languages

Regular expressions define regular languages using only three primitives and three rules:

[cols="3", options="header"]
|===
|Name
|Meaning
|Example

|*Empty Set*
|Reject everything.
|{}

|*Empty String*
|Match the empty string.
|{+""+}

|*Symbol*
|Match a single character.
|{+'a'+}

|*Sequence*
|Match one regular expression followed by one after another.
|If +a+ and +b+ are regular expressions, +ab+ matches +a+ followed by +b+

|*Alternation*
|Match either one regular expression or another.
|If +a+ and +b+ are regular expressions, +a\|b+ matches {+a+, +b+}.

|*Kleene Star*
|Match a regular expression zero or more times.
|If +a+ is a regular expression, +a*+ matches {+""+,+a+,+aa+,+aaa+,...}

|===

== May 9

IMPORTANT: If you haven't already done so by now, <<install-git,install git and frontends>>, and then <<setup-repo,setup your course repository>>.

=== Pre-quiz (How much theory do you know?)

NOTE: Don't worry, this isn't graded (but please do it anyway)

Pretend we're taking a closed-book exam. Answer these questions in a file called +prequiz.txt+ in your repo.

. What is the difference between a set, a bag, and a sequence?
+
Sets, bags and sequences are all collections of items. Sets are unordered collections of unique items, bags are unordered collections of potentially duplicated items, and sequences are ordered collections of potentially duplicated items.

. What is a language (in terms of sets and sequences)?
+
Languages are sets of strings.
. What is a compiler? Name some.
+
Compilers transform one language into another (typically a source language to a machine language).
+
Examples include: +gcc+, +javac+, +ghc+, etc.
. What is the derivative of a language?
. What is a regular expression?
. What is a finite automaton, and what is the difference between an NFA and a DFA?
. What is a grammar, and what is the difference between regular grammars, context-free grammars, LL(k) and LR(k)?
. What is the difference between derivative parsing, recursive-descent parsing, shift-reduce parsing and parser combinators?
. What is a visitor?
. What is the difference between a parse tree and an abstract syntax tree?
. Name some optimizations.
. What questions do you have for me?

Now, let's stage, commit and push our stuff off to ensure git is working.

----
git add prequiz.txt             # Stage prequiz.txt (include in next commit)
git commit -m "Prequiz answers" # Commit changes with a message
git push origin master          # Send work to your private repository
----

== May 7

=== Introduction

. What's your name?
. Why did you pick computer science?
. What do you still want to learn and/or what do you aspire to do after graduation?
. Tell us something nobody else knows about you.

=== https://raw.githubusercontent.com/lawrancej/COMP603-2014/master/COMP603SyllabusLawrance.docx[Syllabus (Word document)]

* Even though you may develop mobile/web apps or games, compilers are relevant to your career.
* Writing compilers give you superpowers: (e.g., http://www.robovm.org/[RoboVM], https://github.com/kripken/emscripten/wiki[emscripten])

=== Install Git and frontends
[[install-git]]
Windows:: https://code.google.com/p/gitextensions/downloads/list[Install Git Extensions, MSysGit and KDiff3].
+
NOTE: Stick to the default settings, but when asked, *choose OpenSSH (not PuTTY)*.

Mac OS X:: http://rowanj.github.io/gitx/[Install GitX-dev].
+
NOTE: https://developer.apple.com/xcode/downloads/[XCode developer tools] ships with git; otherwise, http://git-scm.com/download/mac[install the latest git from here].

Linux:: http://git-scm.com/download/linux[Install git] using your package manager. http://sourceforge.net/projects/qgit/[QGit, a git frontend] may also be available for your distribution.
+
NOTE: Don't forget to use +sudo+ with your package manager.

=== Setup your course repository
[[setup-repo]]
IMPORTANT: You must use LeopardSecure, not LeopardGuest.

All platforms:: Paste this into your terminal (Git Bash on Windows):
+
----
curl https://raw.githubusercontent.com/lawrancej/COMP603-2014/master/starterupper.sh | sh
----
+
NOTE: Press +Insert+ to paste in Git Bash.
