= COMP603 (Compiler Design)

== May 13

Compilers translate source language(s) to target language(s), and typically consist of the following 'phases':

[cols="4", options="header"]
|===
|Phase
|Description
|Input
|Output

|*Scanning / Tokenization*
|Break source code up into small chunks (tokens) such as identifiers, reserved words, operators, etc
|Source code
|Token stream

|*Parsing*
|Check the syntax of the source code
|Token stream
|Parse tree

|*Translation*
|Translate low level syntax into high-level abstract syntax tree
|Parse tree
|Abstract syntax tree, symbol table

|*Optimization*
|Improve performance or structure
|Abstract syntax tree, symbol table
|Abstract synatx tree, symbol table

|*Code generation*
|Traverse the AST to generate code.
|Abstract syntax tree, symbol table
|Target code

|===

=== Lab 1

Do this individually, or in pairs.

NOTE: If working in a pair, go to your github repository settings (on the right side) and add the other person as a collaborator. Then, in your local git repository, add the collaborator's repository as a remote, using +git remote add 'COLLABORATOR' 'SSH_URL'+. Then +git fetch --all+. *DO NOT* push to your collaborator's repository, otherwise they'll be forced to merge in your changes before they can push. Always push to +origin+ (your github repository).

. Choose a single compiler implementation to review (suggestions welcome!)

  * https://github.com/chaoslawful/tcc[Tiny C compiler]
  * https://github.com/mirrors/gcc[GCC (Compiler for C/C++)]
  * https://github.com/llvm-mirror/llvm[LLVM (Compiler for C/C++)]
  * https://github.com/openjdk-mirror/jdk7u-jdk[OpenJDK (Compiler and runtime for Java)]
  * https://github.com/python/cpython[CPython]
  * https://bitbucket.org/pypy/pypy[PyPy]
  * https://github.com/LuaDist/lua[Lua]
  * https://github.com/ghc/ghc[GHC source (Haskell)]
  * https://github.com/ghcjs/ghcjs[GHCJS (Haskell to Javascript compiler)]
  * https://github.com/mozilla/rhino[Java implementation of Javascript]
  * https://github.com/mono/mono[C# compiler and runtime]

. Identify which files/functions are responsible for each phase in the compiler source.
. What was the most ridiculous thing you found? (funny comments? awful code?)
. Take notes along the way (if you find something that's unrelated to a compiler phase, try to infer what it's doing).
. Write up your findings in a short document and post to your repository (no more than two pages, please). For example:
+
----
git add findings.txt
git commit -m "Lab 1 findings."
git push origin master
----

=== Further reading

* http://cm.bell-labs.com/who/ken/trust.html[Reflections on Trusting Trust]
* https://www.schneier.com/blog/archives/2006/01/countering_trus.html[Countering "Trusting Trust"]

== May 12

=== Warm up

Cheat at crosswords (and learn about merge conflicts), the easy way!

. http://puzzles.about.com/library/features/dailyxwd/qprmon.htm[Open this crossword in a new tab]
. Pull from upstream
+
----
cd ~/COMP603-2014         # Go to your repo first
git pull upstream master  # Pull (fetch and merge) the latest and greatest from me
git mergetool             # Use KDiff3 to merge my stuff in (if you have a conflict)
----
. Find words that match something interesting, for example:
+
----
grep foo... american-english.txt
----

=== A case for Theory of Computation

WARNING: Theory of Computation ahead

. The first compiler (for Fortran) took 18 man-years of effort to produce back in the 1950s.
. CS theory has enabled CS undergraduates understand how to construct compilers within a semester.

=== A hierarchy of languages

Even though languages are sets of strings, it'd be difficult to define useful languages by enumerating all the strings in the set.
Therefore, CS theorists and mathematicians have developed handy short-cuts (formal grammars, state machines, etc.) to define languages.
Noam Chomsky categorized languages into a http://en.wikipedia.org/wiki/Chomsky_hierarchy[hierarchy that bears his name].

You've had experience with the most primitive languages (regular languages) and the most complex (recursively enumerable).

=== Regular languages

Regular expressions define regular languages using only three primitives and three rules:

[cols="3", options="header"]
|===
|Name
|Meaning
|Example

|*Empty Set*
|Reject everything.
|{}

|*Empty String*
|Match the empty string.
|{+""+}

|*Symbol*
|Match a single character.
|{+'a'+}

|*Sequence*
|Match one regular expression followed by one after another.
|If +a+ and +b+ are regular expressions, +ab+ matches +a+ followed by +b+

|*Alternation*
|Match either one regular expression or another.
|If +a+ and +b+ are regular expressions, +a\|b+ matches {+a+, +b+}.

|*Kleene Star*
|Match a regular expression zero or more times.
|If +a+ is a regular expression, +a*+ matches {+""+,+a+,+aa+,+aaa+,...}

|===

== May 9

IMPORTANT: If you haven't already done so by now, <<install-git,install git and frontends>>, and then <<setup-repo,setup your course repository>>.

=== Pre-quiz (How much theory do you know?)

NOTE: Don't worry, this isn't graded (but please do it anyway)

Pretend we're taking a closed-book exam. Answer these questions in a file called +prequiz.txt+ in your repo.

. What is the difference between a set, a bag, and a sequence?
. What is a language (in terms of sets and sequences)?
+
Languages are sets of strings.
. What is a compiler? Name some.
+
Compilers transform one language into another (typically a source language to a machine language).
+
Examples include: +gcc+, +javac+, +ghc+, etc.
. What is the derivative of a language?
. What is a regular expression?
. What is a finite automaton, and what is the difference between an NFA and a DFA?
. What is a grammar, and what is the difference between regular grammars, context-free grammars, LL(k) and LR(k)?
. What is the difference between derivative parsing, recursive-descent parsing, shift-reduce parsing and parser combinators?
. What is a visitor?
. What is the difference between a parse tree and an abstract syntax tree?
. Name some optimizations.
. What questions do you have for me?

Now, let's stage, commit and push our stuff off to ensure git is working.

----
git add prequiz.txt             # Stage prequiz.txt (include in next commit)
git commit -m "Prequiz answers" # Commit changes with a message
git push origin master          # Send work to your private repository
----

== May 7

=== Introduction

. What's your name?
. Why did you pick computer science?
. What do you still want to learn and/or what do you aspire to do after graduation?
. Tell us something nobody else knows about you.

=== https://raw.githubusercontent.com/lawrancej/COMP603-2014/master/COMP603SyllabusLawrance.docx[Syllabus (Word document)]

* Even though you may develop mobile/web apps or games, compilers are relevant to your career.
* Writing compilers give you superpowers: (e.g., http://www.robovm.org/[RoboVM], https://github.com/kripken/emscripten/wiki[emscripten])

=== Install Git and frontends
[[install-git]]
Windows:: https://code.google.com/p/gitextensions/downloads/list[Install Git Extensions, MSysGit and KDiff3].
+
NOTE: Stick to the default settings, but when asked, *choose OpenSSH (not PuTTY)*.

Mac OS X:: http://rowanj.github.io/gitx/[Install GitX-dev].
+
NOTE: https://developer.apple.com/xcode/downloads/[XCode developer tools] ships with git; otherwise, http://git-scm.com/download/mac[install the latest git from here].

Linux:: http://git-scm.com/download/linux[Install git] using your package manager. http://sourceforge.net/projects/qgit/[QGit, a git frontend] may also be available for your distribution.
+
NOTE: Don't forget to use +sudo+ with your package manager.

=== Setup your course repository
[[setup-repo]]
IMPORTANT: You must use LeopardSecure, not LeopardGuest.

All platforms:: Paste this into your terminal (Git Bash on Windows):
+
----
curl https://raw.githubusercontent.com/lawrancej/COMP603-2014/master/starterupper.sh | sh
----
+
NOTE: Press +Insert+ to paste in Git Bash.
