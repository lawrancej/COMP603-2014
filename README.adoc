= COMP603 (Compiler Design)

== May 19

=== Warm up

Answer in a file called +warmup.txt+

. What does it mean for two sets to be disjoint?
. What is the union of two sets?

=== First and follow sets

First set:: the set of terminals that can appear first in any derivation of a nonterminal.
Follow set:: the set of terminals that can appear first *after* derivation of a nonterminal.

See the scribbles.

=== LL(k) grammars

LL(k) means parse from *Left* to right, *Leftmost* derivation, with at most *k* tokens of lookahead.

LL(k) grammars are a subset of the context-free grammars. For a grammar to be LL(k):

. The first and follow sets for each nonterminal must be disjoint
. No left-recursion is allowed

LL(k) grammars are interesting because they can be parsed using 'recursive descent'.

=== Recursive descent parsing

Show

== May 16

=== Derivatives

http://matt.might.net/articles/parsing-with-derivatives/[A discussion of derivatives and parsing with them].

=== Grammars

Grammars consist of:

. a finite set of derivation rules (productions)
. a finite set of nonterminals (variables)
. a finite set of terminals (literals)
. a starting nonterminal

Chomsky recognized that the restrictions placed on the form of derivation rules implies what category of language the grammar can recognize or generate.

NOTE: We will focus primarily on two subsets of context-free grammars, LL and LR grammars, since they have efficient parsing algorithms.

[cols="3", options="header"]
|===

|Chomsky hierarchy
|Description
|Equivalent automaton

|*Unrestricted*
|Arbitrary sequences of terminals and non-terminals can derive arbitrary sequences of terminals and nonterminals.
|Turing machine (finite state machine with an infinite tape having a read/write head)

|*Context-sensitive*
|A nonterminal flanked on either side by terminals and nonterminals (the context) derives a nonempty string of terminals or nonterminals surrounded by the same context.
|Turing machine with finite tape (finite state machine with a finite tape having a read/write head)

|*Context-free*
|Nonterminals derive sequences of terminals and nonterminals.
|Pushdown automaton (finite state machine with a stack)

|*Regular*
|A nonterminal can derive a terminal followed by a nonterminal or nothing at all.
|Finite state machine

|===

*Challenge*: Derive the parse tree for +int a = 5;+ using the C grammar. 'Hint:' it's a declaration.

== May 14

=== Warm up

Consider the following (fire up your command line and try these out):

----
echo 'Joey Lawrance' | sed -e 's/\(\w\w*\).*/Hello, \1!/'
echo 'lawrancej@wit.edu' | sed 's/\(.*\)@\(.*\)\.\(.*\)/\1 at \2 dot \3/'
echo 'deadbeef' | sed -e 's/^\([0-9a-f][0-9a-f]*\)$/Hex: \1/'
echo 'deadhorse' | sed -e 's/^\([0-9a-f][0-9a-f]*\)$/Hex: \1/'
----

With somebody sitting nearby, read the commands carefully and discuss these questions. 'Hint': +sed -e s/'REGEX'/'REPLACEMENT'/+

. How do you think it works?
. What do you think +\w+ means?
. What do +\1+, +\2+ and +\3+ mean?
. What does +[0-9a-f]+ mean?
. *Challenge*: Can you write a sed command to match only identifiers in, say, C/C++ or Java? Don't worry about reserved words. 'Hint': massage the last regex into something appropriate.

=== Regular Expressions and Finite State Machines

Regular expressions and finite state machines (finite automata) are interchangeable; we can always convert between them. Even non-deterministic and deterministic finite automata are interchangeable.

*Challenge*: Can you write finite state machines that correspond to the regular expressions above?

== May 13

Compilers translate source language(s) to target language(s), and typically consist of the following 'phases':

[cols="4", options="header"]
|===
|Phase
|Description
|Input
|Output

|*Scanning / Tokenization*
|Break source code up into small chunks (tokens) such as identifiers, reserved words, literals, operators, etc.
|Source code
|Token stream

|*Parsing*
|Check the syntax of the source code
|Token stream
|Parse tree

|*Translation*
|Translate low level syntax into high-level abstract syntax tree
|Parse tree
|Abstract syntax tree, symbol table

|*Optimization*
|Improve performance or structure
|Abstract syntax tree, symbol table
|Abstract synatx tree, symbol table

|*Code generation*
|Traverse the AST to generate code.
|Abstract syntax tree, symbol table
|Target code

|===

=== Lab 1

Do this individually, or in pairs.

NOTE: If working in a pair, go to your github repository settings (on the right side) and add the other person as a collaborator. Then, in your local git repository, add the collaborator's repository as a remote, using +git remote add 'COLLABORATOR' 'SSH_URL'+. Then +git fetch --all+. *DO NOT* push to your collaborator's repository, otherwise they'll be forced to merge in your changes before they can push. Always push to +origin+ (your github repository).

. Choose a single compiler implementation to review (suggestions welcome!)

  * https://github.com/chaoslawful/tcc[Tiny C compiler]
  * https://github.com/mirrors/gcc[GCC (Compiler for C/C++)]
  * https://github.com/llvm-mirror/llvm[LLVM (Compiler for C/C++)]
  * https://github.com/openjdk-mirror/jdk7u-jdk[OpenJDK (Compiler and runtime for Java)]
  * https://github.com/python/cpython[CPython]
  * https://bitbucket.org/pypy/pypy[PyPy]
  * https://github.com/LuaDist/lua[Lua]
  * https://github.com/ghc/ghc[GHC source (Haskell)]
  * https://github.com/ghcjs/ghcjs[GHCJS (Haskell to Javascript compiler)]
  * https://github.com/mozilla/rhino[Java implementation of Javascript]
  * https://github.com/mono/mono[C# compiler and runtime]

. Identify which files/functions are responsible for each phase in the compiler source.
. What was the most ridiculous thing you found? (funny comments? awful code?)
. Take notes along the way (if you find something that's unrelated to a compiler phase, try to infer what it's doing).
. Write up your findings in a short document and post to your repository (no more than two pages, please). For example:
+
----
git add findings.txt
git commit -m "Lab 1 findings."
git push origin master
----

=== Further reading

* http://cm.bell-labs.com/who/ken/trust.html[Reflections on Trusting Trust]
* https://www.schneier.com/blog/archives/2006/01/countering_trus.html[Countering "Trusting Trust"]

== May 12

=== Warm up

Cheat at crosswords (and learn about merge conflicts), the easy way!

. http://puzzles.about.com/library/features/dailyxwd/qprmon.htm[Open this crossword in a new tab]
. Pull from upstream
+
----
cd ~/COMP603-2014         # Go to your repo first
git pull upstream master  # Pull (fetch and merge) the latest and greatest from me
git mergetool             # Use KDiff3 to merge my stuff in (if you have a conflict)
----
. Find words that match something interesting, for example:
+
----
grep foo... american-english.txt
----

=== A case for Theory of Computation

WARNING: Theory of Computation ahead

. The first compiler (for Fortran) took 18 man-years of effort to produce back in the 1950s.
. CS theory has enabled CS undergraduates understand how to construct compilers within a semester.

=== A hierarchy of languages

Even though languages are sets of strings, it'd be difficult to define useful languages by enumerating all the strings in the set.
Therefore, CS theorists and mathematicians have developed handy short-cuts (formal grammars, state machines, etc.) to define languages.
Noam Chomsky categorized languages into a http://en.wikipedia.org/wiki/Chomsky_hierarchy[hierarchy that bears his name].

You've had experience with the most primitive languages (regular languages) and the most complex (recursively enumerable).

=== Regular languages

Regular expressions define regular languages using only three primitives and three rules:

[cols="3", options="header"]
|===
|Name
|Meaning
|Example

|*Empty Set*
|Reject everything.
|{}

|*Empty String*
|Match the empty string.
|{+""+}

|*Symbol*
|Match a single character.
|{+'a'+}

|*Sequence*
|Match one regular expression followed by one after another.
|If +a+ and +b+ are regular expressions, +ab+ matches +a+ followed by +b+

|*Alternation*
|Match either one regular expression or another.
|If +a+ and +b+ are regular expressions, +a\|b+ matches {+a+, +b+}.

|*Kleene Star*
|Match a regular expression zero or more times.
|If +a+ is a regular expression, +a*+ matches {+""+,+a+,+aa+,+aaa+,...}

|===

== May 9

IMPORTANT: If you haven't already done so by now, <<install-git,install git and frontends>>, and then <<setup-repo,setup your course repository>>.

=== Pre-quiz (How much theory do you know?)

NOTE: Don't worry, this isn't graded (but please do it anyway)

Pretend we're taking a closed-book exam. Answer these questions in a file called +prequiz.txt+ in your repo.

. What is the difference between a set, a bag, and a sequence?
+
Sets, bags and sequences are all collections of items. Sets are unordered collections of unique items, bags are unordered collections of potentially duplicated items, and sequences are ordered collections of potentially duplicated items.

. What is a language (in terms of sets and sequences)?
+
Languages are sets of strings.
. What is a compiler? Name some.
+
Compilers transform one language into another (typically a source language to a machine language).
+
Examples include: +gcc+, +javac+, +ghc+, etc.
. What is the derivative of a language?
. What is a regular expression?
. What is a finite automaton, and what is the difference between an NFA and a DFA?
. What is a grammar, and what is the difference between regular grammars, context-free grammars, LL(k) and LR(k)?
. What is the difference between derivative parsing, recursive-descent parsing, shift-reduce parsing and parser combinators?
. What is a visitor?
. What is the difference between a parse tree and an abstract syntax tree?
. Name some optimizations.
. What questions do you have for me?

Now, let's stage, commit and push our stuff off to ensure git is working.

----
git add prequiz.txt             # Stage prequiz.txt (include in next commit)
git commit -m "Prequiz answers" # Commit changes with a message
git push origin master          # Send work to your private repository
----

== May 7

=== Introduction

. What's your name?
. Why did you pick computer science?
. What do you still want to learn and/or what do you aspire to do after graduation?
. Tell us something nobody else knows about you.

=== https://raw.githubusercontent.com/lawrancej/COMP603-2014/master/COMP603SyllabusLawrance.docx[Syllabus (Word document)]

* Even though you may develop mobile/web apps or games, compilers are relevant to your career.
* Writing compilers give you superpowers: (e.g., http://www.robovm.org/[RoboVM], https://github.com/kripken/emscripten/wiki[emscripten])

=== Install Git and frontends
[[install-git]]
Windows:: https://code.google.com/p/gitextensions/downloads/list[Install Git Extensions, MSysGit and KDiff3].
+
NOTE: Stick to the default settings, but when asked, *choose OpenSSH (not PuTTY)*.

Mac OS X:: http://rowanj.github.io/gitx/[Install GitX-dev].
+
NOTE: https://developer.apple.com/xcode/downloads/[XCode developer tools] ships with git; otherwise, http://git-scm.com/download/mac[install the latest git from here].

Linux:: http://git-scm.com/download/linux[Install git] using your package manager. http://sourceforge.net/projects/qgit/[QGit, a git frontend] may also be available for your distribution.
+
NOTE: Don't forget to use +sudo+ with your package manager.

=== Setup your course repository
[[setup-repo]]
IMPORTANT: You must use LeopardSecure, not LeopardGuest.

All platforms:: Paste this into your terminal (Git Bash on Windows):
+
----
curl https://raw.githubusercontent.com/lawrancej/COMP603-2014/master/starterupper.sh | sh
----
+
NOTE: Press +Insert+ to paste in Git Bash.
